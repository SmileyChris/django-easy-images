{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Django Easy Images Documentation Welcome to the documentation for Django Easy Images - a powerful image processing solution for Django projects. What is Django Easy Images? Django Easy Images makes it simple to: Generate responsive HTML <img> tags Automatically create thumbnails and optimized versions Queue image processing for better performance Support modern formats like WebP and AVIF Quick Start from easy_images import Img # Create a thumbnail configuration profile_thumb = Img(width=200, ratio=\"square\") # Generate HTML for a profile photo html = profile_thumb(user.profile.photo, alt=\"User profile\").as_html() Documentation Sections Getting Started - Installation and basic usage Configuration - All available image processing options Advanced Usage - Signals, queue management and performance tips API Reference - Detailed technical documentation Need Help? Found an issue or have questions? Please open an issue on GitHub.","title":"Django Easy Images Documentation"},{"location":"#django-easy-images-documentation","text":"Welcome to the documentation for Django Easy Images - a powerful image processing solution for Django projects.","title":"Django Easy Images Documentation"},{"location":"#what-is-django-easy-images","text":"Django Easy Images makes it simple to: Generate responsive HTML <img> tags Automatically create thumbnails and optimized versions Queue image processing for better performance Support modern formats like WebP and AVIF","title":"What is Django Easy Images?"},{"location":"#quick-start","text":"from easy_images import Img # Create a thumbnail configuration profile_thumb = Img(width=200, ratio=\"square\") # Generate HTML for a profile photo html = profile_thumb(user.profile.photo, alt=\"User profile\").as_html()","title":"Quick Start"},{"location":"#documentation-sections","text":"Getting Started - Installation and basic usage Configuration - All available image processing options Advanced Usage - Signals, queue management and performance tips API Reference - Detailed technical documentation","title":"Documentation Sections"},{"location":"#need-help","text":"Found an issue or have questions? Please open an issue on GitHub.","title":"Need Help?"},{"location":"advanced-usage/","text":"Advanced Usage Queue Management Building Images Images are built either: Via cron job running build_img_queue Or via task runner using the queued_img signal Manual Queueing Queue images manually using the queue method: from easy_images import Img from my_app.models import Product thumbnail = Img(width=300) thumbnail.queue(Product, fields=['main_image']) Automatic Queueing Automatically queue images when a FileField is saved using signals : from django.apps import AppConfig from my_app.images import thumbnail class MyAppConfig(AppConfig): def ready(self): from my_app.models import Profile thumbnail.queue(Profile, build=\"src\") Batch Processing When rendering multiple images (e.g., in a list view), use ImageBatch to optimize database queries: from easy_images import ImageBatch, Img def product_list_view(request): products = Product.objects.all() # Create a batch for efficient processing batch = ImageBatch() thumbnail = Img(batch=batch, width=300, format=\"webp\") # Process all images product_images = [] for product in products: bound_img = thumbnail(product.image, alt=product.name) product_images.append({ 'product': product, 'image': bound_img }) # First access triggers batch loading of all images # Subsequent accesses use cached data return render(request, 'products.html', { 'product_images': product_images }) Benefits of Batching Reduced Database Queries : One query loads all image metadata instead of N queries Shared Processing : Images with the same source share processing results Memory Efficiency : Fresh batches prevent memory accumulation Incremental Loading : Can add images to already-loaded batches Batch Building Strategies # Option 1: Automatic building on property access (default) batch = ImageBatch() img = Img(batch=batch, width=300) bound = img(file, build=\"src\") url = bound.base_url() # Triggers auto-build # Option 2: Explicit batch building batch = ImageBatch() img = Img(batch=batch, width=300) bound1 = img(file1, build=\"src\") bound2 = img(file2, build=\"srcset\") batch.build() # Build all at once # Option 3: Immediate building (for signals/queue) img = Img(width=300) bound = img(file, build=\"src\", immediate=True) Performance Tips For high-traffic sites, use build=\"src\" to generate base images immediately Use ImageBatch when rendering lists of images Set up Celery for distributed image processing Use format=\"webp\" for best compression/performance balance Limit densities to [2] unless high-DPI support is critical (or turn it off entirely) Consider pre-generating common image sizes during deployment Signals file_post_save Triggered when a FileField is saved. Use to automatically queue images: from django.apps import AppConfig from my_app.images import thumbnail class MyAppConfig(AppConfig): def ready(self): from my_app.models import Profile thumbnail.queue(Profile, build=\"src\") queued_img Triggered when images need building. Use with Celery: from easy_images.management.process_queue import process_queue from easy_images.signals import queued_img @app.task def build_img_queue(): process_queue() # In apps.py: queued_img.connect(lambda **kwargs: build_img_queue.delay(), weak=False)","title":"Advanced Usage"},{"location":"advanced-usage/#advanced-usage","text":"","title":"Advanced Usage"},{"location":"advanced-usage/#queue-management","text":"","title":"Queue Management"},{"location":"advanced-usage/#building-images","text":"Images are built either: Via cron job running build_img_queue Or via task runner using the queued_img signal","title":"Building Images"},{"location":"advanced-usage/#manual-queueing","text":"Queue images manually using the queue method: from easy_images import Img from my_app.models import Product thumbnail = Img(width=300) thumbnail.queue(Product, fields=['main_image'])","title":"Manual Queueing"},{"location":"advanced-usage/#automatic-queueing","text":"Automatically queue images when a FileField is saved using signals : from django.apps import AppConfig from my_app.images import thumbnail class MyAppConfig(AppConfig): def ready(self): from my_app.models import Profile thumbnail.queue(Profile, build=\"src\")","title":"Automatic Queueing"},{"location":"advanced-usage/#batch-processing","text":"When rendering multiple images (e.g., in a list view), use ImageBatch to optimize database queries: from easy_images import ImageBatch, Img def product_list_view(request): products = Product.objects.all() # Create a batch for efficient processing batch = ImageBatch() thumbnail = Img(batch=batch, width=300, format=\"webp\") # Process all images product_images = [] for product in products: bound_img = thumbnail(product.image, alt=product.name) product_images.append({ 'product': product, 'image': bound_img }) # First access triggers batch loading of all images # Subsequent accesses use cached data return render(request, 'products.html', { 'product_images': product_images })","title":"Batch Processing"},{"location":"advanced-usage/#benefits-of-batching","text":"Reduced Database Queries : One query loads all image metadata instead of N queries Shared Processing : Images with the same source share processing results Memory Efficiency : Fresh batches prevent memory accumulation Incremental Loading : Can add images to already-loaded batches","title":"Benefits of Batching"},{"location":"advanced-usage/#batch-building-strategies","text":"# Option 1: Automatic building on property access (default) batch = ImageBatch() img = Img(batch=batch, width=300) bound = img(file, build=\"src\") url = bound.base_url() # Triggers auto-build # Option 2: Explicit batch building batch = ImageBatch() img = Img(batch=batch, width=300) bound1 = img(file1, build=\"src\") bound2 = img(file2, build=\"srcset\") batch.build() # Build all at once # Option 3: Immediate building (for signals/queue) img = Img(width=300) bound = img(file, build=\"src\", immediate=True)","title":"Batch Building Strategies"},{"location":"advanced-usage/#performance-tips","text":"For high-traffic sites, use build=\"src\" to generate base images immediately Use ImageBatch when rendering lists of images Set up Celery for distributed image processing Use format=\"webp\" for best compression/performance balance Limit densities to [2] unless high-DPI support is critical (or turn it off entirely) Consider pre-generating common image sizes during deployment","title":"Performance Tips"},{"location":"advanced-usage/#signals","text":"","title":"Signals"},{"location":"advanced-usage/#file_post_save","text":"Triggered when a FileField is saved. Use to automatically queue images: from django.apps import AppConfig from my_app.images import thumbnail class MyAppConfig(AppConfig): def ready(self): from my_app.models import Profile thumbnail.queue(Profile, build=\"src\")","title":"file_post_save"},{"location":"advanced-usage/#queued_img","text":"Triggered when images need building. Use with Celery: from easy_images.management.process_queue import process_queue from easy_images.signals import queued_img @app.task def build_img_queue(): process_queue() # In apps.py: queued_img.connect(lambda **kwargs: build_img_queue.delay(), weak=False)","title":"queued_img"},{"location":"api/","text":"API Reference Core Modules easy_images.core Main functionality for image processing with these key classes: Img - Image Configuration from easy_images import Img # Basic usage img = Img(width=800, format='webp', quality=85) processed_img = img(my_model.image_field) # Chaining configurations responsive_img = ( Img(width=1200) .extend(width=800, sizes={'768': 600, '480': 400}) ) # Automatic processing on model save img.queue(MyModel) # Processes all ImageFields on MyModel ImageBatch - Batch Processing The ImageBatch class optimizes database queries when processing multiple images: from easy_images import ImageBatch, Img # Create a shared batch for efficient processing batch = ImageBatch() # Create image configurations with the batch img = Img(batch=batch, width=800, format=\"webp\") thumbnail = Img(batch=batch, width=200, format=\"jpg\") # Add images to the batch bound1 = img(model1.image_field, alt=\"Main image\") bound2 = thumbnail(model2.image_field, alt=\"Thumbnail\") # Access images - batch loading happens automatically html1 = bound1.as_html() # First access triggers batch loading html2 = bound2.as_html() # Already loaded, no extra queries # Or explicitly build all images in the batch batch.build() Key benefits: - Batches database queries for multiple images - Shares loaded image data across all items in the batch - Supports incremental loading when adding images to an already-loaded batch - Automatic lazy building when properties are accessed BoundImg - Processed Image A BoundImg represents a single image item within a batch: # Properties (trigger auto-building if needed) main_url = bound_img.base_url() # URL of the base image srcset_items = bound_img.srcset # List of SrcSetItem objects alt_text = bound_img.alt # Alt text sizes_attr = bound_img.sizes # Sizes attribute for responsive images html = bound_img.as_html() # Complete <img> tag # Check if images are built if bound_img.is_built: print(\"Images are ready\") # Manually trigger building bound_img.build('all') # Options: 'all', 'src', 'srcset' easy_images.engine Image processing engine implementation easy_images.models Database models for storing image information Management Commands easy_images Manages the EasyImage queue with subcommands for building, requeuing, and checking status. This is the primary command for managing image processing. Basic Usage # Show queue status (default action) python manage.py easy_images python manage.py easy_images status # Build queued images python manage.py easy_images build # Requeue failed images python manage.py easy_images requeue Subcommands status (default) Shows queue statistics and current state. Supports multiple output formats and health gates: # Auto format: pretty on TTY, plain otherwise python manage.py easy_images status # Explicit formats python manage.py easy_images status --format pretty python manage.py easy_images status --format plain python manage.py easy_images status --format json # Options python manage.py easy_images status --stale-after 600 # Stale BUILDING threshold (seconds) python manage.py easy_images status --verbose # Show error distribution python manage.py easy_images status --fail-on-stale # Exit non-zero if stale builds exist python manage.py easy_images status --fail-on-errors 5 # Exit non-zero if errors > 5 Plain/pretty output includes: - Total source images (distinct storage+name) - Total generated images - Total images in queue (unbuilt: queued+building+errors) - Average generated per source - Breakdown by status (queued, building with stale count, errors split by type) - Error count distribution (with --verbose ) - Suggestions (commands to remediate) Example (pretty): Summary: 7 sources | 3 generated (0.43/src) | 5 queued | 2 building (1 stale) | 2 errors (S:1 B:1) Totals: Total source images: 7 Total generated images: 3 Total images in queue: 5 Avg generated per source: 0.43 Breakdown: Queued: 5 \u2588\u2588\u2588\u2588\u2588 Building: 2 \u2588\u2588 (1 stale > 600s) Errors: 2 \u2588\u2588 (source: 1, build: 1) Suggestions: python manage.py easy_images build --stale-after 600 python manage.py easy_images requeue --max-errors 3 JSON schema: { \"counts\": { \"sources\": 7, \"generated\": 3, \"queued\": 5, \"building\": 2, \"source_errors\": 1, \"build_errors\": 1 }, \"avg_per_source\": 0.43, \"stale\": { \"threshold_seconds\": 600, \"count\": 1 }, \"error_dist\": [{ \"error_count\": 1, \"count\": 2 }], \"suggestions\": [ \"python manage.py easy_images build --stale-after 600\", \"python manage.py easy_images requeue --max-errors 3\" ] } build Processes queued images with intelligent stale detection: python manage.py easy_images build python manage.py easy_images build --stale-after 300 # Stale if BUILDING > 5 minutes python manage.py easy_images build --max-errors 3 # Skip images with > 3 errors python manage.py easy_images build --verbose # Show detailed progress Options: - --stale-after <seconds> - Images stuck in BUILDING status longer than this are considered stale and reprocessed (default: 600 seconds) - --max-errors <count> - Only retry images with at most this many previous errors - --verbose - Show detailed progress and error information requeue Resets failed images back to QUEUED status for reprocessing: python manage.py easy_images requeue python manage.py easy_images requeue --max-errors 5 # Only if \u2264 5 errors python manage.py easy_images requeue --include-stale # Also requeue stale builds Options: - --max-errors <count> - Only requeue images with at most this many errors - --include-stale - Also requeue images stuck in BUILDING status - --stale-after <seconds> - With --include-stale, defines stale threshold (default: 600) Image Processing States Queued - New images waiting to be processed Building - Images currently being processed (auto-detected as stale if too old) Built - Successfully processed images Source Error - Source file couldn't be accessed Build Error - Failed during processing Smart Stale Detection The command automatically handles crashed or stuck builds by checking the status_changed_date : - Images in BUILDING status with recent timestamps are skipped (actually building) - Images in BUILDING status with old timestamps are treated as stale and reprocessed - No need for manual --force flag in most cases Integration Examples Cron Job - Regular processing with automatic stale handling: bash # Process queue every 5 minutes */5 * * * * /path/to/python /path/to/manage.py easy_images build Error Recovery Workflow : ```bash # Check current status python manage.py easy_images # Requeue failed images with < 3 errors python manage.py easy_images requeue --max-errors 3 # Process the requeued images python manage.py easy_images build ``` Monitoring Script : ```bash # Pretty output for humans (TTY) python manage.py easy_images status --stale-after 600 --verbose # JSON for machines python manage.py easy_images status --format json --stale-after 600 # Fail CI/monitoring if stale builds or too many errors python manage.py easy_images status --fail-on-stale --fail-on-errors 0 ``` build_img_queue (Deprecated) \u26a0\ufe0f Deprecated: This command is maintained for backwards compatibility. Please use easy_images build instead. # Old command (deprecated) python manage.py build_img_queue --retry 3 # New equivalent python manage.py easy_images build --max-errors 3 The old command will continue to work but displays a deprecation warning. It maps to the new command with these defaults: - --retry \u2192 --max-errors - Stale detection enabled with 600 second threshold - All other behavior remains the same Template Tags easy_images Template tags for rendering processed images: {% load easy_images %} <!-- Basic usage --> {% easy_image obj.image_field width=800 %} <!-- With responsive sizes --> {% easy_image obj.image_field width=1200 sizes=\"(max-width: 768px) 600px, (max-width: 480px) 400px\" %} <!-- With additional HTML attributes using img_ prefix --> {% img obj.image_field width=\"md\" alt=\"Product\" img_class=\"rounded-lg\" img_loading=\"lazy\" img_data_id=\"123\" %} The template tag supports adding custom HTML attributes to the generated <img> element by prefixing them with img_ . For example: - img_class=\"my-class\" becomes class=\"my-class\" - img_loading=\"lazy\" becomes loading=\"lazy\" - img_data_id=\"123\" becomes data-id=\"123\"","title":"API Reference"},{"location":"api/#api-reference","text":"","title":"API Reference"},{"location":"api/#core-modules","text":"","title":"Core Modules"},{"location":"api/#easy_imagescore","text":"Main functionality for image processing with these key classes:","title":"easy_images.core"},{"location":"api/#img-image-configuration","text":"from easy_images import Img # Basic usage img = Img(width=800, format='webp', quality=85) processed_img = img(my_model.image_field) # Chaining configurations responsive_img = ( Img(width=1200) .extend(width=800, sizes={'768': 600, '480': 400}) ) # Automatic processing on model save img.queue(MyModel) # Processes all ImageFields on MyModel","title":"Img - Image Configuration"},{"location":"api/#imagebatch-batch-processing","text":"The ImageBatch class optimizes database queries when processing multiple images: from easy_images import ImageBatch, Img # Create a shared batch for efficient processing batch = ImageBatch() # Create image configurations with the batch img = Img(batch=batch, width=800, format=\"webp\") thumbnail = Img(batch=batch, width=200, format=\"jpg\") # Add images to the batch bound1 = img(model1.image_field, alt=\"Main image\") bound2 = thumbnail(model2.image_field, alt=\"Thumbnail\") # Access images - batch loading happens automatically html1 = bound1.as_html() # First access triggers batch loading html2 = bound2.as_html() # Already loaded, no extra queries # Or explicitly build all images in the batch batch.build() Key benefits: - Batches database queries for multiple images - Shares loaded image data across all items in the batch - Supports incremental loading when adding images to an already-loaded batch - Automatic lazy building when properties are accessed","title":"ImageBatch - Batch Processing"},{"location":"api/#boundimg-processed-image","text":"A BoundImg represents a single image item within a batch: # Properties (trigger auto-building if needed) main_url = bound_img.base_url() # URL of the base image srcset_items = bound_img.srcset # List of SrcSetItem objects alt_text = bound_img.alt # Alt text sizes_attr = bound_img.sizes # Sizes attribute for responsive images html = bound_img.as_html() # Complete <img> tag # Check if images are built if bound_img.is_built: print(\"Images are ready\") # Manually trigger building bound_img.build('all') # Options: 'all', 'src', 'srcset'","title":"BoundImg - Processed Image"},{"location":"api/#easy_imagesengine","text":"Image processing engine implementation","title":"easy_images.engine"},{"location":"api/#easy_imagesmodels","text":"Database models for storing image information","title":"easy_images.models"},{"location":"api/#management-commands","text":"","title":"Management Commands"},{"location":"api/#easy_images","text":"Manages the EasyImage queue with subcommands for building, requeuing, and checking status. This is the primary command for managing image processing.","title":"easy_images"},{"location":"api/#basic-usage","text":"# Show queue status (default action) python manage.py easy_images python manage.py easy_images status # Build queued images python manage.py easy_images build # Requeue failed images python manage.py easy_images requeue","title":"Basic Usage"},{"location":"api/#subcommands","text":"","title":"Subcommands"},{"location":"api/#status-default","text":"Shows queue statistics and current state. Supports multiple output formats and health gates: # Auto format: pretty on TTY, plain otherwise python manage.py easy_images status # Explicit formats python manage.py easy_images status --format pretty python manage.py easy_images status --format plain python manage.py easy_images status --format json # Options python manage.py easy_images status --stale-after 600 # Stale BUILDING threshold (seconds) python manage.py easy_images status --verbose # Show error distribution python manage.py easy_images status --fail-on-stale # Exit non-zero if stale builds exist python manage.py easy_images status --fail-on-errors 5 # Exit non-zero if errors > 5 Plain/pretty output includes: - Total source images (distinct storage+name) - Total generated images - Total images in queue (unbuilt: queued+building+errors) - Average generated per source - Breakdown by status (queued, building with stale count, errors split by type) - Error count distribution (with --verbose ) - Suggestions (commands to remediate) Example (pretty): Summary: 7 sources | 3 generated (0.43/src) | 5 queued | 2 building (1 stale) | 2 errors (S:1 B:1) Totals: Total source images: 7 Total generated images: 3 Total images in queue: 5 Avg generated per source: 0.43 Breakdown: Queued: 5 \u2588\u2588\u2588\u2588\u2588 Building: 2 \u2588\u2588 (1 stale > 600s) Errors: 2 \u2588\u2588 (source: 1, build: 1) Suggestions: python manage.py easy_images build --stale-after 600 python manage.py easy_images requeue --max-errors 3 JSON schema: { \"counts\": { \"sources\": 7, \"generated\": 3, \"queued\": 5, \"building\": 2, \"source_errors\": 1, \"build_errors\": 1 }, \"avg_per_source\": 0.43, \"stale\": { \"threshold_seconds\": 600, \"count\": 1 }, \"error_dist\": [{ \"error_count\": 1, \"count\": 2 }], \"suggestions\": [ \"python manage.py easy_images build --stale-after 600\", \"python manage.py easy_images requeue --max-errors 3\" ] }","title":"status (default)"},{"location":"api/#build","text":"Processes queued images with intelligent stale detection: python manage.py easy_images build python manage.py easy_images build --stale-after 300 # Stale if BUILDING > 5 minutes python manage.py easy_images build --max-errors 3 # Skip images with > 3 errors python manage.py easy_images build --verbose # Show detailed progress Options: - --stale-after <seconds> - Images stuck in BUILDING status longer than this are considered stale and reprocessed (default: 600 seconds) - --max-errors <count> - Only retry images with at most this many previous errors - --verbose - Show detailed progress and error information","title":"build"},{"location":"api/#requeue","text":"Resets failed images back to QUEUED status for reprocessing: python manage.py easy_images requeue python manage.py easy_images requeue --max-errors 5 # Only if \u2264 5 errors python manage.py easy_images requeue --include-stale # Also requeue stale builds Options: - --max-errors <count> - Only requeue images with at most this many errors - --include-stale - Also requeue images stuck in BUILDING status - --stale-after <seconds> - With --include-stale, defines stale threshold (default: 600)","title":"requeue"},{"location":"api/#image-processing-states","text":"Queued - New images waiting to be processed Building - Images currently being processed (auto-detected as stale if too old) Built - Successfully processed images Source Error - Source file couldn't be accessed Build Error - Failed during processing","title":"Image Processing States"},{"location":"api/#smart-stale-detection","text":"The command automatically handles crashed or stuck builds by checking the status_changed_date : - Images in BUILDING status with recent timestamps are skipped (actually building) - Images in BUILDING status with old timestamps are treated as stale and reprocessed - No need for manual --force flag in most cases","title":"Smart Stale Detection"},{"location":"api/#integration-examples","text":"Cron Job - Regular processing with automatic stale handling: bash # Process queue every 5 minutes */5 * * * * /path/to/python /path/to/manage.py easy_images build Error Recovery Workflow : ```bash # Check current status python manage.py easy_images # Requeue failed images with < 3 errors python manage.py easy_images requeue --max-errors 3 # Process the requeued images python manage.py easy_images build ``` Monitoring Script : ```bash # Pretty output for humans (TTY) python manage.py easy_images status --stale-after 600 --verbose # JSON for machines python manage.py easy_images status --format json --stale-after 600 # Fail CI/monitoring if stale builds or too many errors python manage.py easy_images status --fail-on-stale --fail-on-errors 0 ```","title":"Integration Examples"},{"location":"api/#build_img_queue-deprecated","text":"\u26a0\ufe0f Deprecated: This command is maintained for backwards compatibility. Please use easy_images build instead. # Old command (deprecated) python manage.py build_img_queue --retry 3 # New equivalent python manage.py easy_images build --max-errors 3 The old command will continue to work but displays a deprecation warning. It maps to the new command with these defaults: - --retry \u2192 --max-errors - Stale detection enabled with 600 second threshold - All other behavior remains the same","title":"build_img_queue (Deprecated)"},{"location":"api/#template-tags","text":"","title":"Template Tags"},{"location":"api/#easy_images_1","text":"Template tags for rendering processed images: {% load easy_images %} <!-- Basic usage --> {% easy_image obj.image_field width=800 %} <!-- With responsive sizes --> {% easy_image obj.image_field width=1200 sizes=\"(max-width: 768px) 600px, (max-width: 480px) 400px\" %} <!-- With additional HTML attributes using img_ prefix --> {% img obj.image_field width=\"md\" alt=\"Product\" img_class=\"rounded-lg\" img_loading=\"lazy\" img_data_id=\"123\" %} The template tag supports adding custom HTML attributes to the generated <img> element by prefixing them with img_ . For example: - img_class=\"my-class\" becomes class=\"my-class\" - img_loading=\"lazy\" becomes loading=\"lazy\" - img_data_id=\"123\" becomes data-id=\"123\"","title":"easy_images"},{"location":"configuration/","text":"Configuration Options Image Processing Options width Limit the width of the image. Can be: Integer (pixels) Tailwind size string: \"xs\", \"sm\", \"md\", \"lg\", \"screen-sm\", \"screen-md\", \"screen-lg\", \"screen-xl\", \"screen-2xl\" Img(width=300) # Fixed width Img(width=\"md\") # Responsive width ratio The aspect ratio of the image. Can be: Float (e.g. 4/5 ) String: \"square\", \"video\" (16/9), \"video_vertical\", \"golden\", \"golden_vertical\" Img(ratio=\"square\") # 1:1 ratio Img(ratio=16/9) # Custom ratio crop How to crop the image: True (default): Crop from center (0.5, 0.5) False : Don't crop (use CSS object-fit instead) Tuple: (x%, y%) crop position String: Position keywords like \"tl\", \"tr\", \"bl\", \"br\", \"l\", \"r\", \"t\", \"b\" Img(crop=\"tl\") # Crop from top-left Img(crop=False) # No cropping quality Image compression quality (default: 80) Img(quality=90) # Higher quality contain When resizing the image (and not cropping), contain the image within the requested ratio. This ensures it will always fit within the requested dimensions and prevents upscaling. \u26a0\ufe0f Default values differ by usage: - Python API ( Img() ): True (default) - Image is contained within dimensions, no upscaling - Template tag ( {% img %} ): False (default) - Image covers the requested ratio (may exceed dimensions) # Python API Img(contain=False) # Override to allow image to cover/exceed dimensions # Template tag {% img file my_img contain=True %} # Override to contain within dimensions Advanced Options sizes Responsive sizes for different media queries: Img( width=300, sizes={ \"print\": {\"width\": 450, \"quality\": 90}, 800: 100 # Max-width 800px } ) format srcset image format (default: \"webp\"): \"webp\" (recommended) \"avif\" (memory intensive) \"jpeg\" Img(format=\"avif\") # Use AVIF format focal_window Zoom area specified as (x1%, y1%, x2%, y2%): Img(focal_window=(25, 25, 75, 75)) # Zoom center 50% of image densities Higher density versions to generate (default: [2] ): Img(densities=[1.5, 2, 3]) # Generate 1.5x, 2x and 3x versions","title":"Configuration"},{"location":"configuration/#configuration-options","text":"","title":"Configuration Options"},{"location":"configuration/#image-processing-options","text":"","title":"Image Processing Options"},{"location":"configuration/#width","text":"Limit the width of the image. Can be: Integer (pixels) Tailwind size string: \"xs\", \"sm\", \"md\", \"lg\", \"screen-sm\", \"screen-md\", \"screen-lg\", \"screen-xl\", \"screen-2xl\" Img(width=300) # Fixed width Img(width=\"md\") # Responsive width","title":"width"},{"location":"configuration/#ratio","text":"The aspect ratio of the image. Can be: Float (e.g. 4/5 ) String: \"square\", \"video\" (16/9), \"video_vertical\", \"golden\", \"golden_vertical\" Img(ratio=\"square\") # 1:1 ratio Img(ratio=16/9) # Custom ratio","title":"ratio"},{"location":"configuration/#crop","text":"How to crop the image: True (default): Crop from center (0.5, 0.5) False : Don't crop (use CSS object-fit instead) Tuple: (x%, y%) crop position String: Position keywords like \"tl\", \"tr\", \"bl\", \"br\", \"l\", \"r\", \"t\", \"b\" Img(crop=\"tl\") # Crop from top-left Img(crop=False) # No cropping","title":"crop"},{"location":"configuration/#quality","text":"Image compression quality (default: 80) Img(quality=90) # Higher quality","title":"quality"},{"location":"configuration/#contain","text":"When resizing the image (and not cropping), contain the image within the requested ratio. This ensures it will always fit within the requested dimensions and prevents upscaling. \u26a0\ufe0f Default values differ by usage: - Python API ( Img() ): True (default) - Image is contained within dimensions, no upscaling - Template tag ( {% img %} ): False (default) - Image covers the requested ratio (may exceed dimensions) # Python API Img(contain=False) # Override to allow image to cover/exceed dimensions # Template tag {% img file my_img contain=True %} # Override to contain within dimensions","title":"contain"},{"location":"configuration/#advanced-options","text":"","title":"Advanced Options"},{"location":"configuration/#sizes","text":"Responsive sizes for different media queries: Img( width=300, sizes={ \"print\": {\"width\": 450, \"quality\": 90}, 800: 100 # Max-width 800px } )","title":"sizes"},{"location":"configuration/#format","text":"srcset image format (default: \"webp\"): \"webp\" (recommended) \"avif\" (memory intensive) \"jpeg\" Img(format=\"avif\") # Use AVIF format","title":"format"},{"location":"configuration/#focal_window","text":"Zoom area specified as (x1%, y1%, x2%, y2%): Img(focal_window=(25, 25, 75, 75)) # Zoom center 50% of image","title":"focal_window"},{"location":"configuration/#densities","text":"Higher density versions to generate (default: [2] ): Img(densities=[1.5, 2, 3]) # Generate 1.5x, 2x and 3x versions","title":"densities"},{"location":"getting-started/","text":"Getting Started Installation pip install django-easy-images Add to your Django settings: INSTALLED_APPS = [ \"easy_images\", # ... ] Dependencies You'll need libvips installed: MacOS : brew install vips Ubuntu : sudo apt-get install --no-install-recommends libvips Arch : sudo pacman -S libvips Basic Usage Using the Img class from easy_images import Img # Create an image configuration thumb = Img(width=\"md\") # Generate HTML for an image html = thumb(profile.photo, alt=\"Profile photo\").as_html() # Add extra attributes to the image html = thumb(profile.photo, alt=\"Profile photo\").as_html(img_attrs={\"loading\": \"lazy\"}) Batch Processing for Multiple Images When working with multiple images, use ImageBatch for better performance: from easy_images import Img, ImageBatch # Create a batch for efficient processing batch = ImageBatch() thumb = Img(batch=batch, width=\"md\") # Process multiple images images = [] for profile in profiles: bound_img = thumb(profile.photo, alt=f\"{profile.name}'s photo\") images.append(bound_img) # First access loads all images in one query for img in images: print(img.as_html()) See the API documentation for more details. Using template tags {% load easy_images %} <!-- Basic usage --> {% img report.image width=\"md\" alt=\"\" %} <!-- With predefined Img instance --> {% img report.image thumb alt=\"\" %} Next Steps Configuration Options Advanced Usage","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/#installation","text":"pip install django-easy-images Add to your Django settings: INSTALLED_APPS = [ \"easy_images\", # ... ]","title":"Installation"},{"location":"getting-started/#dependencies","text":"You'll need libvips installed: MacOS : brew install vips Ubuntu : sudo apt-get install --no-install-recommends libvips Arch : sudo pacman -S libvips","title":"Dependencies"},{"location":"getting-started/#basic-usage","text":"","title":"Basic Usage"},{"location":"getting-started/#using-the-img-class","text":"from easy_images import Img # Create an image configuration thumb = Img(width=\"md\") # Generate HTML for an image html = thumb(profile.photo, alt=\"Profile photo\").as_html() # Add extra attributes to the image html = thumb(profile.photo, alt=\"Profile photo\").as_html(img_attrs={\"loading\": \"lazy\"})","title":"Using the Img class"},{"location":"getting-started/#batch-processing-for-multiple-images","text":"When working with multiple images, use ImageBatch for better performance: from easy_images import Img, ImageBatch # Create a batch for efficient processing batch = ImageBatch() thumb = Img(batch=batch, width=\"md\") # Process multiple images images = [] for profile in profiles: bound_img = thumb(profile.photo, alt=f\"{profile.name}'s photo\") images.append(bound_img) # First access loads all images in one query for img in images: print(img.as_html()) See the API documentation for more details.","title":"Batch Processing for Multiple Images"},{"location":"getting-started/#using-template-tags","text":"{% load easy_images %} <!-- Basic usage --> {% img report.image width=\"md\" alt=\"\" %} <!-- With predefined Img instance --> {% img report.image thumb alt=\"\" %}","title":"Using template tags"},{"location":"getting-started/#next-steps","text":"Configuration Options Advanced Usage","title":"Next Steps"}]}